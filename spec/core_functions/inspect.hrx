<===> error/no_args/input.scss
a {a: inspect()}

<===> error/no_args/error
Error: Missing argument $value.
  ,
1 | a {a: inspect()}
  |       ^^^^^^^^^
  '
  input.scss 1:7  root stylesheet

<===> error/no_args/error-libsass
Error: Function inspect is missing argument $value.
        on line 1 of input.scss
>> a {a: inspect()}

   ------^

<===>
================================================================================
<===> error/two_args/input.scss
a {a: inspect(1, 2)}

<===> error/two_args/error
Error: Only 1 argument allowed, but 2 were passed.
  ,
1 | a {a: inspect(1, 2)}
  |       ^^^^^^^^^^^^^
  '
  input.scss 1:7  root stylesheet

<===> error/two_args/error-libsass
Error: wrong number of arguments (2 for 1) for `inspect'
        on line 1:7 of input.scss
>> a {a: inspect(1, 2)}

   ------^

<===>
================================================================================
<===> number/unitless/input.scss
a {
  $result: inspect(123.456);
  result: $result;
  type: type-of($result);
}

<===> number/unitless/output.css
a {
  result: 123.456;
  type: string;
}

<===>
================================================================================
<===> string/unquoted/input.scss
a {
  $result: inspect(foo);
  result: $result;
  type: type-of($result);
}

<===> string/unquoted/output.css
a {
  result: foo;
  type: string;
}

<===>
================================================================================
<===> string/quoted/input.scss
a {
  $result: inspect("foo");
  result: $result;
  type: type-of($result);

  // inspect() should always return an unquoted string, so when it's passed a
  // quoted string its return value should contain quote characters. We check
  // the length to verify that the quotes are included, since there's no
  // built-in way to check whether a string is quoted.
  length: str-length($result);
}

<===> string/quoted/output.css
a {
  result: "foo";
  type: string;
  length: 5;
}

<===>
================================================================================
<===> number/unit/input.scss
// We explicitly don't test the inspect format for complex units. Their format
// isn't guaranteed by the spec, since they can't be written literally in Sass.
a {
  $result: inspect(50px);
  result: $result;
  type: type-of($result);
}

<===> number/unit/output.css
a {
  result: 50px;
  type: string;
}

<===>
================================================================================
<===> color/literal/README.md
When colors are written literally by the user, rather than being generated by a
function, inspect() should return them in the same format the user wrote them.

<===>
================================================================================
<===> color/literal/short_hex/input.scss
a {
  $result: inspect(#00f);
  result: $result;
  type: type-of($result);
}

<===> color/literal/short_hex/output.css
a {
  result: #00f;
  type: string;
}

<===>
================================================================================
<===> color/literal/long_hex/input.scss
a {
  $result: inspect(#0000ff);
  result: $result;
  type: type-of($result);
}

<===> color/literal/long_hex/output.css
a {
  result: #0000ff;
  type: string;
}

<===>
================================================================================
<===> color/literal/named/input.scss
a {
  $result: inspect(blue);
  result: $result;
  type: type-of($result);
}

<===> color/literal/named/output.css
a {
  result: blue;
  type: string;
}

<===>
================================================================================
<===> color/literal/transparent/input.scss
a {
  $result: inspect(transparent);
  result: $result;
  type: type-of($result);
}

<===> color/literal/transparent/output.css
a {
  result: transparent;
  type: string;
}

<===>
================================================================================
<===> color/generated/README.md
A color that's generated from a function should be returned as rgba() if its
alpha channel is anything other than 1, or the color name if it has one, or else
the hex code.

<===>
================================================================================
<===> color/generated/alpha/input.scss
a {
  $result: inspect(rgba(1, 2, 3, 0.4));
  result: $result;
  type: type-of($result);
}

<===> color/generated/alpha/output.css
a {
  result: rgba(1, 2, 3, 0.4);
  type: string;
}

<===>
================================================================================
<===> color/generated/transparent/input.scss
a {
  // This scale-color() call is a no-op, but it will return a non-literal color
  // value.
  $result: inspect(scale-color(transparent, $blue: 0%));
  result: $result;
  type: type-of($result);
}

<===> color/generated/transparent/output.css
a {
  result: rgba(0, 0, 0, 0);
  type: string;
}

<===>
================================================================================
<===> color/generated/named/input.scss
a {
  // This scale-color() call is a no-op, but it will return a non-literal color
  // value.
  $result: inspect(scale-color(#00f, $blue: 0%));
  result: $result;
  type: type-of($result);
}

<===> color/generated/named/output.css
a {
  result: blue;
  type: string;
}

<===>
================================================================================
<===> color/generated/short_hex/input.scss
a {
  // This scale-color() call is a no-op, but it will return a non-literal color
  // value.
  $result: inspect(scale-color(#abc, $blue: 0%));
  result: $result;
  type: type-of($result);
}

<===> color/generated/short_hex/output.css
a {
  result: #aabbcc;
  type: string;
}

<===>
================================================================================
<===> color/generated/long_hex/input.scss
a {
  $result: inspect(rgb(171, 205, 239));
  result: $result;
  type: type-of($result);
}

<===> color/generated/long_hex/output.css
a {
  result: #abcdef;
  type: string;
}

<===>
================================================================================
<===> boolean/input.scss
a {
  $result: inspect(true);
  result: $result;
  type: type-of($result);
}

<===> boolean/output.css
a {
  result: true;
  type: string;
}

<===>
================================================================================
<===> null/input.scss
a {
  $result: inspect(null);
  result: $result;
  type: type-of($result);
}

<===> null/output.css
a {
  result: null;
  type: string;
}

<===>
================================================================================
<===> list/empty/input.scss
a {
  $result: inspect(());
  result: $result;
  type: type-of($result);
}

<===> list/empty/output.css
a {
  result: ();
  type: string;
}

<===>
================================================================================
<===> list/single_with_comma/input.scss
a {
  $result: inspect((1,));
  result: $result;
  type: type-of($result);
}

<===> list/single_with_comma/output.css
a {
  result: (1,);
  type: string;
}

<===>
================================================================================
<===> list/space/input.scss
a {
  $result: inspect(1 2 3);
  result: $result;
  type: type-of($result);
}

<===> list/space/output.css
a {
  result: 1 2 3;
  type: string;
}

<===>
================================================================================
<===> list/comma/input.scss
a {
  $result: inspect((1, 2, 3));
  result: $result;
  type: type-of($result);
}

<===> list/comma/output.css
a {
  result: 1, 2, 3;
  type: string;
}

<===>
================================================================================
<===> list/bracketed/input.scss
a {
  $result: inspect([1, 2, 3]);
  result: $result;
  type: type-of($result);
}

<===> list/bracketed/output.css
a {
  result: [1, 2, 3];
  type: string;
}

<===> list/nested/input.scss
a {
  $a: inspect([() ()]);
  a: $a;
  b: type-of($a);
}

<===> list/nested/output.css
a {
  a: [() ()];
  b: string;
}

<===>
================================================================================
<===> map/input.scss
a {
  $result: inspect((1: 2, 3: 4));
  result: $result;
  type: type-of($result);
}

<===> map/output.css
a {
  result: (1: 2, 3: 4);
  type: string;
}
